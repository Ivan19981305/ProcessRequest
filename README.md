# ProcessRequest
Тестовое задание для компании Инфомаксимум

# Тестовое задание C++ разработчик

## Описание

Это решение тестового задания, включающее реализацию многопоточной обработки запросов с использованием `Win32 API`, `STL` и принципов синхронизации.

## Задача

Реализовать программу с использованием C++, которая обрабатывает запросы, поступающие из функции `GetRequest()`.  Программа должна:

* Создать несколько рабочих потоков.
* Получать запросы из `GetRequest()`.
* Помещать запросы в очередь.
* Обрабатывать запросы в рабочих потоках с помощью `ProcessRequest()`.
* Корректно завершать работу потоков при получении сигнала остановки (`nullptr` из `GetRequest()`).
* Освобождать всю выделенную память.

## Реализация

Решение включает следующие файлы:

* **Request.h:** Объявление класса `Request`.
* **Request.cpp:** Реализация класса `Request`.
* **main.cpp:**  Основная логика программы, включая функции `GetRequest()`, `ProcessRequest()`, `workerThread()` и `main()`.

**Основные компоненты:**

* **Класс `Request`:** Представляет собой запрос с уникальным идентификатором (`id`).
* **Функция `GetRequest()`:**  Возвращает указатель на новый `Request` или `nullptr` для сигнализации завершения.
* **Функция `ProcessRequest()`:**  Обрабатывает переданный запрос.
* **Рабочие потоки (`workerThread`)**:  Извлекают запросы из очереди и обрабатывают их.
* **Очередь (`taskQueue`)**: Хранит запросы, ожидающие обработки.
* **Синхронизация:** Используется `std::mutex` для защиты очереди и `std::condition_variable` для сигнализации потокам.

## Компиляция

Для компиляции программы используйте компилятор C++, например g++:
# Тестовое задание C++ разработчик

## Описание

Это решение тестового задания, включающее реализацию многопоточной обработки запросов с использованием `Win32 API`, `STL` и принципов синхронизации.

## Задача

Реализовать программу с использованием C++, которая обрабатывает запросы, поступающие из функции `GetRequest()`.  Программа должна:

* Создать несколько рабочих потоков.
* Получать запросы из `GetRequest()`.
* Помещать запросы в очередь.
* Обрабатывать запросы в рабочих потоках с помощью `ProcessRequest()`.
* Корректно завершать работу потоков при получении сигнала остановки (`nullptr` из `GetRequest()`).
* Освобождать всю выделенную память.

## Реализация

Решение включает следующие файлы:

* **Request.h:** Объявление класса `Request`.
* **Request.cpp:** Реализация класса `Request`.
* **main.cpp:**  Основная логика программы, включая функции `GetRequest()`, `ProcessRequest()`, `workerThread()` и `main()`.

**Основные компоненты:**

* **Класс `Request`:** Представляет собой запрос с уникальным идентификатором (`id`).
* **Функция `GetRequest()`:**  Возвращает указатель на новый `Request` или `nullptr` для сигнализации завершения.
* **Функция `ProcessRequest()`:**  Обрабатывает переданный запрос.
* **Рабочие потоки (`workerThread`)**:  Извлекают запросы из очереди и обрабатывают их.
* **Очередь (`taskQueue`)**: Хранит запросы, ожидающие обработки.
* **Синхронизация:** Используется `std::mutex` для защиты очереди и `std::condition_variable` для сигнализации потокам.

## Компиляция

Для компиляции программы используйте компилятор C++, например g++:

```bash
g++ -o ProcessRequest main.cpp Request.cpp 

Запуск
Запустите скомпилированный файл:
./ProcessRequest
